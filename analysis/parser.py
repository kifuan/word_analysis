import re
from abc import ABC, abstractmethod
from typing import Type


# A dict that contains qid with all words they sent.
WordData = dict[str, list[str]]


class ScanningError(Exception):
    ...


class ConcreateParserTable:
    def __init__(self):
        self.table = {}

    def get(self, name: str) -> 'MessageParser':
        if name not in self.table:
            raise KeyError(f'no parser named {name}')
        return self.table[name]

    def register(self, name: str):
        def wrapper(t: Type['MessageParser']):
            self.table[name] = t()
            return t
        return wrapper


concreate_parser = ConcreateParserTable()


class MessageParser(ABC):
    @abstractmethod
    def parse_metadata(self, line: str, line_number: int) -> tuple[bool, str]:
        ...

    @staticmethod
    def get_parser(name: str) -> 'MessageParser':
        return concreate_parser.get(name)

    def parse_file(self, path: str) -> WordData:
        with open(path, 'r', encoding='utf-8') as f:
            lines = [line.strip('\n') for line in f if line.strip('\n') != '']
        result = {}
        # The state of scanning.
        scanning_state = False
        # The metadata it is scanning for.
        scanning_for = ''
        i = 0
        while i < len(lines):
            is_metadata, metadata = self.parse_metadata(lines[i], i)
            if scanning_state:
                # End of scanning for this term.
                if is_metadata:
                    # Note that we don't increment i there,
                    # so that next loop will enter is_metadata branch.
                    scanning_state = False
                    continue
                result[scanning_for].append(lines[i])
                # Scan for next message, skip this line.
                i += 1
            elif is_metadata:
                scanning_state = True
                scanning_for = metadata
                result.setdefault(metadata, [])
                # Scan for messages, skip this line.
                i += 1
            else:
                raise ScanningError(
                    f'This line is neither message nor metadata.'
                    f'Line number: {i + 1}\n'
                    f'Content: {lines[i]}'
                )

        return result


def starts_with_date(line: str):
    # It starts with date.
    return bool(re.search(r'^(\d{4}-\d{2}-\d{2}.+)', line))


@concreate_parser.register('group')
class GroupMessageParser(MessageParser):
    def parse_metadata(self, line: str, line_number: int) -> tuple[bool, str]:
        # It starts with date.
        if not starts_with_date(line):
            if line_number == 0:
                raise ScanningError(
                    'You should ensure that you removed BOM and'
                    'extra lines auto-generated by QQ following README.MD'
                )
            # Just ignore the line if it is not the first.
            return False, ''

        # Try to find it with ().
        brackets = re.findall(r'[(](.*?)[)]', line)
        if brackets:
            return True, brackets[-1]

        # Try to find it with <>.
        angel_brackets = re.findall(r'[<](.*?)[>]', line)
        if angel_brackets:
            return True, angel_brackets[-1]

        raise ScanningError(
            f'Cannot find qid or email in line {line_number + 1}, but this line'
            'starts with regular datetime, which is what we want.'
        )


@concreate_parser.register('friend')
class FriendMessageParser(MessageParser):
    def parse_metadata(self, line: str, line_number: int) -> tuple[bool, str]:
        if not starts_with_date(line):
            if line_number == 0:
                raise ScanningError(
                    'You should ensure that you removed BOM and'
                    'extra lines auto-generated by QQ following README.MD'
                )
            return False, ''

        # Just remove the date prefix.
        return True, re.sub(r'^(\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2}\s*)', '', line)
