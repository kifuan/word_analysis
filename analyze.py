import sys
import jieba
import collections
import re
import matplotlib.pyplot as plt
from typing import *

# ==========
# | Parser |
# ===========


class ScanningError(Exception):
    ...


def parse_metadata(line: str, current_line: int) -> Tuple[bool, str]:
    # It starts with date
    if not re.search(r'^(\d{4}-\d{2}-\d{2}.+)', line):
        if current_line == 0:
            raise ScanningError('You should ensure that you removed BOM and extra lines auto-generated by QQ following '
                                'README.MD')
        return False, ''

    # Try to find it with ()
    brackets = re.findall(r'[(](.*?)[)]', line)
    if brackets:
        return True, brackets[-1]

    # Try to find it with <>
    angel_brackets = re.findall(r'[<](.*?)[>]', line)
    if angel_brackets:
        return True, angel_brackets[-1]

    raise ScanningError(f'Cannot find qid or email in line {current_line+1}, but this line starts with regular '
                        f'datetime, which is what we want.')


def parse_file(lines: List[str]) -> Dict[str, List[str]]:
    result = dict()
    # The state of scanning.
    scanning_state = False
    # The metadata it is scanning for.
    scanning_for = ''
    i = 0
    while i < len(lines):
        is_metadata, metadata = parse_metadata(lines[i], i)
        if scanning_state:
            # End of scanning for this term.
            if is_metadata:
                # Note that we don't increment i there,
                # so that next loop will enter is_metadata branch.
                scanning_state = False
                continue
            result[scanning_for].append(lines[i])
            # Scan for next message, skip this line.
            i += 1
        elif is_metadata:
            scanning_state = True
            scanning_for = metadata
            result.setdefault(metadata, [])
            # Scan for messages, skip this line.
            i += 1
        else:
            raise ScanningError(f'It is not scanning and this line is not metadata. Current line: {i+1}')

    return result


def parse(txt_path: str) -> Dict[str, List[str]]:
    with open(txt_path, 'r', encoding='utf-8') as f:
        lines = [line.strip('\n') for line in f if line.strip('\n') != '']
    return parse_file(lines)


# ========
# | Plot |
# ========

# Support for Chinese characters
plt.rcParams["font.sans-serif"] = ['Microsoft YaHei', 'Heiti']


def preprocess_messages(messages: List[str]) -> List[str]:
    # Remove emoji, spaces, [xxx], @xxx
    useless_pattern = re.compile(r'[\U00010000-\U0010ffff]|\s|(\[.*?])|(@.+\s)')
    messages_with_empty = [useless_pattern.sub('', msg) for msg in messages]
    return [msg for msg in messages_with_empty if msg != '']


def count_words(messages: List[str]) -> Dict[str, int]:
    words = []
    for message in messages:
        words.extend(jieba.cut(message))
    return collections.Counter(words)


def plot(data: Dict[str, List[str]], qid: str, limit: int):
    if qid not in data.keys():
        raise KeyError(f'{qid} does not exist in the file.'
                       'Please ensure that you should find him/her by QQ ID or Email.')

    messages = preprocess_messages(data[qid])
    counter = count_words(messages)
    # Sort the words by frequencies
    items = sorted(counter.items(), key=lambda x: x[1], reverse=True)[:limit]
    words, nums = zip(*items)
    plt.bar(words, nums)
    plt.title(f'{qid}的词频 - Top{limit}')
    plt.show()


def main():
    name, qid, limit = sys.argv[1:]
    limit = int(limit)
    data = parse(f'{name}.txt')
    plot(data, qid, limit)


if __name__ == '__main__':
    main()
